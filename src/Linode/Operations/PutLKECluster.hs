-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the different functions to run the operation putLKECluster
module Linode.Operations.PutLKECluster where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Linode.Common
import Linode.Types
import Linode.ManualTypes

-- | > PUT /lke/clusters/{clusterId}
-- 
-- Updates a Kubernetes cluster.
putLKECluster :: forall m s . (Linode.Common.MonadHTTP m, Linode.Common.SecurityScheme s) => Linode.Common.Configuration s  -- ^ The configuration to use in the request
  -> GHC.Base.Maybe PutLKEClusterRequestBody                                                                                   -- ^ The request body to send
  -> m (Data.Either.Either Network.HTTP.Client.Types.HttpException (Network.HTTP.Client.Types.Response PutLKEClusterResponse)) -- ^ Monad containing the result of the operation
putLKECluster config
              body = GHC.Base.fmap (GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PutLKEClusterResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutLKEClusterResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         PutLKEClusterResponseBody200)
                                                                                                                                                                            | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0)) (Linode.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack "/lke/clusters/{clusterId}") [] body Linode.Common.RequestBodyEncodingJSON)
-- | > PUT /lke/clusters/{clusterId}
-- 
-- The same as 'putLKECluster' but returns the raw 'Data.ByteString.Char8.ByteString'
putLKEClusterRaw :: forall m s . (Linode.Common.MonadHTTP m,
                                  Linode.Common.SecurityScheme s) =>
                    Linode.Common.Configuration s ->
                    GHC.Base.Maybe PutLKEClusterRequestBody ->
                    m (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                          (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
putLKEClusterRaw config
                 body = GHC.Base.id (Linode.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack "/lke/clusters/{clusterId}") [] body Linode.Common.RequestBodyEncodingJSON)
-- | > PUT /lke/clusters/{clusterId}
-- 
-- Monadic version of 'putLKECluster' (use with 'Linode.Common.runWithConfiguration')
putLKEClusterM :: forall m s . (Linode.Common.MonadHTTP m,
                                Linode.Common.SecurityScheme s) =>
                  GHC.Base.Maybe PutLKEClusterRequestBody ->
                  Control.Monad.Trans.Reader.ReaderT (Linode.Common.Configuration s)
                                                     m
                                                     (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                         (Network.HTTP.Client.Types.Response PutLKEClusterResponse))
putLKEClusterM body = GHC.Base.fmap (GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either PutLKEClusterResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutLKEClusterResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                          PutLKEClusterResponseBody200)
                                                                                                                                                                             | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2)) (Linode.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack "/lke/clusters/{clusterId}") [] body Linode.Common.RequestBodyEncodingJSON)
-- | > PUT /lke/clusters/{clusterId}
-- 
-- Monadic version of 'putLKEClusterRaw' (use with 'Linode.Common.runWithConfiguration')
putLKEClusterRawM :: forall m s . (Linode.Common.MonadHTTP m,
                                   Linode.Common.SecurityScheme s) =>
                     GHC.Base.Maybe PutLKEClusterRequestBody ->
                     Control.Monad.Trans.Reader.ReaderT (Linode.Common.Configuration s)
                                                        m
                                                        (Data.Either.Either Network.HTTP.Client.Types.HttpException
                                                                            (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString))
putLKEClusterRawM body = GHC.Base.id (Linode.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") (Data.Text.pack "/lke/clusters/{clusterId}") [] body Linode.Common.RequestBodyEncodingJSON)
-- | Defines the data type for the schema putLKEClusterRequestBody
-- 
-- 
data PutLKEClusterRequestBody = PutLKEClusterRequestBody {
  -- | control_plane: Defines settings for the Kubernetes Control Plane. Allows for the enabling of High Availability (HA) for Control Plane Components.
  -- 
  -- Enabling High Availability for LKE is an **irreversible** change.
  -- 
  -- When upgrading pre-existing LKE clusters to use the HA Control Plane, the following changes will additionally occur:
  -- 
  -- - All nodes will be deleted and new nodes will be created to replace them.
  -- 
  -- - Any local storage (such as \`hostPath\` volumes) will be erased.
  -- 
  -- - The upgrade process may take several minutes to complete, as nodes will be replaced on a rolling basis.
  putLKEClusterRequestBodyControl_plane :: (GHC.Base.Maybe PutLKEClusterRequestBodyControl_plane)
  -- | k8s_version: The desired Kubernetes version for this Kubernetes cluster in the format of &lt;major&gt;.&lt;minor&gt;. New and recycled Nodes in this cluster will be installed with the latest available patch for the Cluster\'s Kubernetes version.
  -- 
  -- When upgrading the Kubernetes version, only the next latest minor version following the current version can be deployed. For example, a cluster with Kubernetes version 1.19 can be upgraded to version 1.20, but not directly to 1.21.
  -- 
  -- The Kubernetes version of a cluster can not be downgraded.
  , putLKEClusterRequestBodyK8s_version :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | label
  , putLKEClusterRequestBodyLabel :: (GHC.Base.Maybe LKECluster_properties_label)
  -- | tags: An array of tags applied to the Kubernetes cluster. Tags are for organizational purposes only. To delete a tag, exclude it from your \`tags\` array.
  , putLKEClusterRequestBodyTags :: (GHC.Base.Maybe ([] Data.Text.Internal.Text))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutLKEClusterRequestBody
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "control_plane" (putLKEClusterRequestBodyControl_plane obj) : (Data.Aeson..=) "k8s_version" (putLKEClusterRequestBodyK8s_version obj) : (Data.Aeson..=) "label" (putLKEClusterRequestBodyLabel obj) : (Data.Aeson..=) "tags" (putLKEClusterRequestBodyTags obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "control_plane" (putLKEClusterRequestBodyControl_plane obj) GHC.Base.<> ((Data.Aeson..=) "k8s_version" (putLKEClusterRequestBodyK8s_version obj) GHC.Base.<> ((Data.Aeson..=) "label" (putLKEClusterRequestBodyLabel obj) GHC.Base.<> (Data.Aeson..=) "tags" (putLKEClusterRequestBodyTags obj))))
instance Data.Aeson.Types.FromJSON.FromJSON PutLKEClusterRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutLKEClusterRequestBody" (\obj -> (((GHC.Base.pure PutLKEClusterRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "control_plane")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "k8s_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tags"))
-- | Defines the data type for the schema putLKEClusterRequestBodyControl_plane
-- 
-- Defines settings for the Kubernetes Control Plane. Allows for the enabling of High Availability (HA) for Control Plane Components.
-- 
-- Enabling High Availability for LKE is an **irreversible** change.
-- 
-- When upgrading pre-existing LKE clusters to use the HA Control Plane, the following changes will additionally occur:
-- 
-- - All nodes will be deleted and new nodes will be created to replace them.
-- 
-- - Any local storage (such as \`hostPath\` volumes) will be erased.
-- 
-- - The upgrade process may take several minutes to complete, as nodes will be replaced on a rolling basis.
data PutLKEClusterRequestBodyControl_plane = PutLKEClusterRequestBodyControl_plane {
  -- | high_availability: Defines whether High Availability is enabled for the Control Plane Components of the cluster. Defaults to \`false\`.
  putLKEClusterRequestBodyControl_planeHigh_availability :: (GHC.Base.Maybe GHC.Types.Bool)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutLKEClusterRequestBodyControl_plane
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "high_availability" (putLKEClusterRequestBodyControl_planeHigh_availability obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "high_availability" (putLKEClusterRequestBodyControl_planeHigh_availability obj))
instance Data.Aeson.Types.FromJSON.FromJSON PutLKEClusterRequestBodyControl_plane
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutLKEClusterRequestBodyControl_plane" (\obj -> GHC.Base.pure PutLKEClusterRequestBodyControl_plane GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "high_availability"))
-- | Represents a response of the operation 'putLKECluster'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PutLKEClusterResponseError' is used.
data PutLKEClusterResponse =                               
   PutLKEClusterResponseError GHC.Base.String              -- ^ Means either no matching case available or a parse error
  | PutLKEClusterResponse200 PutLKEClusterResponseBody200  -- ^ Returns a single Kubernetes cluster.
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the data type for the schema PutLKEClusterResponseBody200
-- 
-- 
data PutLKEClusterResponseBody200 = PutLKEClusterResponseBody200 {
  -- | created
  putLKEClusterResponseBody200Created :: (GHC.Base.Maybe LKECluster_properties_created)
  -- | k8s_version
  , putLKEClusterResponseBody200K8s_version :: (GHC.Base.Maybe LKECluster_properties_k8s_version)
  -- | label
  , putLKEClusterResponseBody200Label :: (GHC.Base.Maybe LKECluster_properties_label)
  -- | region
  , putLKEClusterResponseBody200Region :: (GHC.Base.Maybe LKECluster_properties_region)
  -- | tags: An array of tags applied to the Kubernetes cluster. Tags are for organizational purposes only. To delete a tag, exclude it from your \`tags\` array.
  , putLKEClusterResponseBody200Tags :: (GHC.Base.Maybe ([] Data.Text.Internal.Text))
  -- | updated
  , putLKEClusterResponseBody200Updated :: (GHC.Base.Maybe LKECluster_properties_updated)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON PutLKEClusterResponseBody200
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "created" (putLKEClusterResponseBody200Created obj) : (Data.Aeson..=) "k8s_version" (putLKEClusterResponseBody200K8s_version obj) : (Data.Aeson..=) "label" (putLKEClusterResponseBody200Label obj) : (Data.Aeson..=) "region" (putLKEClusterResponseBody200Region obj) : (Data.Aeson..=) "tags" (putLKEClusterResponseBody200Tags obj) : (Data.Aeson..=) "updated" (putLKEClusterResponseBody200Updated obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "created" (putLKEClusterResponseBody200Created obj) GHC.Base.<> ((Data.Aeson..=) "k8s_version" (putLKEClusterResponseBody200K8s_version obj) GHC.Base.<> ((Data.Aeson..=) "label" (putLKEClusterResponseBody200Label obj) GHC.Base.<> ((Data.Aeson..=) "region" (putLKEClusterResponseBody200Region obj) GHC.Base.<> ((Data.Aeson..=) "tags" (putLKEClusterResponseBody200Tags obj) GHC.Base.<> (Data.Aeson..=) "updated" (putLKEClusterResponseBody200Updated obj))))))
instance Data.Aeson.Types.FromJSON.FromJSON PutLKEClusterResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutLKEClusterResponseBody200" (\obj -> (((((GHC.Base.pure PutLKEClusterResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "k8s_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "region")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tags")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "updated"))
