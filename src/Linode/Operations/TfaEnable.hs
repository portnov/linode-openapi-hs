-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation tfaEnable
module Linode.Operations.TfaEnable where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Linode.Common
import Linode.Types

-- | > POST /profile/tfa-enable
-- 
-- Generates a Two Factor secret for your User. TFA will not be enabled until you have successfully confirmed the code you were given with [tfa-enable-confirm](\/docs\/api\/profile\/\#two-factor-secret-create) (see below). Once enabled, logins from untrusted computers will be required to provide a TFA code before they are successful.
tfaEnable :: forall m . Linode.Common.MonadHTTP m => Linode.Common.ClientT m (Network.HTTP.Client.Types.Response TfaEnableResponse) -- ^ Monadic computation which returns the result of the operation
tfaEnable = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either TfaEnableResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> TfaEnableResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                         TfaEnableResponseBody200)
                                                                                                                                                | GHC.Base.const GHC.Types.True (Network.HTTP.Client.Types.responseStatus response) -> TfaEnableResponseDefault Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                           TfaEnableResponseBodyDefault)
                                                                                                                                                | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Linode.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/profile/tfa-enable") GHC.Base.mempty)
-- | Represents a response of the operation 'tfaEnable'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'TfaEnableResponseError' is used.
data TfaEnableResponse =
   TfaEnableResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | TfaEnableResponse200 TfaEnableResponseBody200 -- ^ Two Factor secret generated
  | TfaEnableResponseDefault TfaEnableResponseBodyDefault -- ^ Error
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/profile\/tfa-enable.POST.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data TfaEnableResponseBody200 = TfaEnableResponseBody200 {
  -- | expiry: When this Two Factor secret expires.
  tfaEnableResponseBody200Expiry :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | secret: Your Two Factor secret. This is used to generate time-based two factor codes required for logging in. Doing this will be required to confirm TFA an actually enable it.
  , tfaEnableResponseBody200Secret :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON TfaEnableResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object ("expiry" Data.Aeson.Types.ToJSON..= tfaEnableResponseBody200Expiry obj : "secret" Data.Aeson.Types.ToJSON..= tfaEnableResponseBody200Secret obj : GHC.Base.mempty)
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("expiry" Data.Aeson.Types.ToJSON..= tfaEnableResponseBody200Expiry obj) GHC.Base.<> ("secret" Data.Aeson.Types.ToJSON..= tfaEnableResponseBody200Secret obj))
instance Data.Aeson.Types.FromJSON.FromJSON TfaEnableResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "TfaEnableResponseBody200" (\obj -> (GHC.Base.pure TfaEnableResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "expiry")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "secret"))
-- | Create a new 'TfaEnableResponseBody200' with all required fields.
mkTfaEnableResponseBody200 :: TfaEnableResponseBody200
mkTfaEnableResponseBody200 = TfaEnableResponseBody200{tfaEnableResponseBody200Expiry = GHC.Maybe.Nothing,
                                                      tfaEnableResponseBody200Secret = GHC.Maybe.Nothing}
-- | Defines the object schema located at @components.responses.ErrorResponse.content.application\/json.schema@ in the specification.
-- 
-- 
data TfaEnableResponseBodyDefault = TfaEnableResponseBodyDefault {
  -- | errors
  tfaEnableResponseBodyDefaultErrors :: (GHC.Maybe.Maybe ([ErrorObject]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON TfaEnableResponseBodyDefault
    where toJSON obj = Data.Aeson.Types.Internal.object ("errors" Data.Aeson.Types.ToJSON..= tfaEnableResponseBodyDefaultErrors obj : GHC.Base.mempty)
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs ("errors" Data.Aeson.Types.ToJSON..= tfaEnableResponseBodyDefaultErrors obj)
instance Data.Aeson.Types.FromJSON.FromJSON TfaEnableResponseBodyDefault
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "TfaEnableResponseBodyDefault" (\obj -> GHC.Base.pure TfaEnableResponseBodyDefault GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "errors"))
-- | Create a new 'TfaEnableResponseBodyDefault' with all required fields.
mkTfaEnableResponseBodyDefault :: TfaEnableResponseBodyDefault
mkTfaEnableResponseBodyDefault = TfaEnableResponseBodyDefault{tfaEnableResponseBodyDefaultErrors = GHC.Maybe.Nothing}
