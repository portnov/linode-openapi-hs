-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation createServiceTransfer
module Linode.Operations.CreateServiceTransfer where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Linode.Common
import Linode.Types

-- | > POST /account/service-transfers
-- 
-- Creates a transfer request for the specified services. A request can contain any of the specified service types
-- and any number of each service type. At this time, only Linodes can be transferred.
-- 
-- When created successfully, a confirmation email is sent to the account that created this transfer containing a
-- transfer token and instructions on completing the transfer.
-- 
-- When a transfer is [accepted](\/docs\/api\/account\/\#service-transfer-accept), the requested services are moved to
-- the receiving account. Linode services will not experience interruptions due to the transfer process. Backups
-- for Linodes are transferred as well.
-- 
-- DNS records that are associated with requested services will not be transferred or updated. Please ensure that
-- associated DNS records have been updated or communicated to the recipient prior to the transfer.
-- 
-- A transfer can take up to three hours to complete once accepted. When a transfer is
-- completed, billing for transferred services ends for the sending account and begins for the receiving account.
-- 
-- This command can only be accessed by the unrestricted users of an account.
-- 
-- There are several conditions that must be met in order to successfully create a transfer request:
-- 
-- 1. The account creating the transfer must not have a past due balance or active Terms of Service violation.
-- 
-- 1. The service must be owned by the account that is creating the transfer.
-- 
-- 1. The service must not be assigned to another Service Transfer that is pending or that has been accepted and is
-- incomplete.
-- 
-- 1. Linodes must not:
-- 
--     * be assigned to a NodeBalancer, Firewall, VLAN, or Managed Service.
-- 
--     * have any attached Block Storage Volumes.
-- 
--     * have any shared IP addresses.
-- 
--     * have any assigned \/56, \/64, or \/116 IPv6 ranges.
createServiceTransfer :: forall m . Linode.Common.MonadHTTP m => GHC.Maybe.Maybe CreateServiceTransferRequestBody -- ^ The request body to send
  -> Linode.Common.ClientT m (Network.HTTP.Client.Types.Response CreateServiceTransferResponse) -- ^ Monadic computation which returns the result of the operation
createServiceTransfer body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either CreateServiceTransferResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> CreateServiceTransferResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                  ServiceTransfer)
                                                                                                                                                                             | GHC.Base.const GHC.Types.True (Network.HTTP.Client.Types.responseStatus response) -> CreateServiceTransferResponseDefault Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                    CreateServiceTransferResponseBodyDefault)
                                                                                                                                                                             | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Linode.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/account/service-transfers") GHC.Base.mempty body Linode.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/account\/service-transfers.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data CreateServiceTransferRequestBody = CreateServiceTransferRequestBody {
  -- | entities: A collection of the services to include in this transfer request, separated by type.
  createServiceTransferRequestBodyEntities :: ServiceTransferPropertiesEntities
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateServiceTransferRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object ("entities" Data.Aeson.Types.ToJSON..= createServiceTransferRequestBodyEntities obj : GHC.Base.mempty)
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs ("entities" Data.Aeson.Types.ToJSON..= createServiceTransferRequestBodyEntities obj)
instance Data.Aeson.Types.FromJSON.FromJSON CreateServiceTransferRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateServiceTransferRequestBody" (\obj -> GHC.Base.pure CreateServiceTransferRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "entities"))
-- | Create a new 'CreateServiceTransferRequestBody' with all required fields.
mkCreateServiceTransferRequestBody :: ServiceTransferPropertiesEntities -- ^ 'createServiceTransferRequestBodyEntities'
  -> CreateServiceTransferRequestBody
mkCreateServiceTransferRequestBody createServiceTransferRequestBodyEntities = CreateServiceTransferRequestBody{createServiceTransferRequestBodyEntities = createServiceTransferRequestBodyEntities}
-- | Represents a response of the operation 'createServiceTransfer'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'CreateServiceTransferResponseError' is used.
data CreateServiceTransferResponse =
   CreateServiceTransferResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | CreateServiceTransferResponse200 ServiceTransfer -- ^ Returns a Service Transfer object for the request. 
  | CreateServiceTransferResponseDefault CreateServiceTransferResponseBodyDefault -- ^ Error
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @components.responses.ErrorResponse.content.application\/json.schema@ in the specification.
-- 
-- 
data CreateServiceTransferResponseBodyDefault = CreateServiceTransferResponseBodyDefault {
  -- | errors
  createServiceTransferResponseBodyDefaultErrors :: (GHC.Maybe.Maybe ([ErrorObject]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateServiceTransferResponseBodyDefault
    where toJSON obj = Data.Aeson.Types.Internal.object ("errors" Data.Aeson.Types.ToJSON..= createServiceTransferResponseBodyDefaultErrors obj : GHC.Base.mempty)
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs ("errors" Data.Aeson.Types.ToJSON..= createServiceTransferResponseBodyDefaultErrors obj)
instance Data.Aeson.Types.FromJSON.FromJSON CreateServiceTransferResponseBodyDefault
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateServiceTransferResponseBodyDefault" (\obj -> GHC.Base.pure CreateServiceTransferResponseBodyDefault GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "errors"))
-- | Create a new 'CreateServiceTransferResponseBodyDefault' with all required fields.
mkCreateServiceTransferResponseBodyDefault :: CreateServiceTransferResponseBodyDefault
mkCreateServiceTransferResponseBodyDefault = CreateServiceTransferResponseBodyDefault{createServiceTransferResponseBodyDefaultErrors = GHC.Maybe.Nothing}
