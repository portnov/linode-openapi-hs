-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains all types with cyclic dependencies (between each other or to itself)
module Linode.CyclicTypes where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Linode.Common
import Linode.Types.AccountSettings
import Linode.Types.AuthorizedApp
import Linode.Types.CreditCard
import Linode.Types.CreditCardData
import Linode.Types.Device
import Linode.Types.Disk
import Linode.Types.Domain
import Linode.Types.DomainRecord
import Linode.Types.EntityTransfer
import Linode.Types.ErrorObject
import Linode.Types.Event
import Linode.Types.FirewallDevices
import Linode.Types.FirewallRuleConfig
import Linode.Types.GooglePayData
import Linode.Types.Grant
import Linode.Types.IPAddress
import Linode.Types.IPAddressPrivate
import Linode.Types.IPAddressV6LinkLocal
import Linode.Types.IPAddressV6Slaac
import Linode.Types.IPv6Pool
import Linode.Types.IPv6Range
import Linode.Types.IPv6RangeBGP
import Linode.Types.Image
import Linode.Types.Invoice
import Linode.Types.InvoiceItem
import Linode.Types.Kernel
import Linode.Types.LKECluster
import Linode.Types.LKENodeStatus
import Linode.Types.LKEVersion
import Linode.Types.Linode
import Linode.Types.LinodeConfigInterface
import Linode.Types.LinodeStats
import Linode.Types.LinodeType
import Linode.Types.Login
import Linode.Types.LongviewClient
import Linode.Types.LongviewPlan
import Linode.Types.LongviewSubscription
import Linode.Types.Maintenance
import Linode.Types.ManagedContact
import Linode.Types.ManagedCredential
import Linode.Types.ManagedIssue
import Linode.Types.ManagedLinodeSettings
import Linode.Types.ManagedService
import Linode.Types.NodeBalancer
import Linode.Types.NodeBalancerConfig
import Linode.Types.NodeBalancerNode
import Linode.Types.NodeBalancerStats
import Linode.Types.Notification
import Linode.Types.OAuthClient
import Linode.Types.ObjectStorageBucket
import Linode.Types.ObjectStorageCluster
import Linode.Types.ObjectStorageKey
import Linode.Types.ObjectStorageObject
import Linode.Types.ObjectStorageSSL
import Linode.Types.ObjectStorageSSLResponse
import Linode.Types.PaginationEnvelope
import Linode.Types.PayPal
import Linode.Types.PayPalData
import Linode.Types.PayPalExecute
import Linode.Types.Payment
import Linode.Types.PaymentRequest
import Linode.Types.PersonalAccessToken
import Linode.Types.Profile
import Linode.Types.Promotion
import Linode.Types.Region
import Linode.Types.SSHKey
import Linode.Types.SSHKeyRequest
import Linode.Types.ServiceTransfer
import Linode.Types.StatsData
import Linode.Types.StatsDataUnavailable
import Linode.Types.SupportTicket
import Linode.Types.SupportTicketReply
import Linode.Types.SupportTicketRequest
import Linode.Types.Tag
import Linode.Types.Transfer
import Linode.Types.TrustedDevice
import Linode.Types.User
import Linode.Types.UserDefinedField
import Linode.Types.Vlans
import Linode.Types.WarningObject
import Linode.Types.Account
import Linode.Types.Devices
import Linode.Types.Firewall
import Linode.Types.GrantsResponse
import Linode.Types.LKENodePool
import Linode.Types.LinodeConfigInterfaces
import Linode.Types.PaymentMethod
import Linode.Types.RescueDevices
import Linode.Types.StackScript
import Linode.Types.StatsDataAvailable
import Linode.Types.LinodeConfig

import Linode.ManualTypes

-- | Defines the data type for the schema Backup
-- 
-- An object representing a Backup or snapshot for a Linode with Backup service enabled.
data Backup = Backup {
  -- | configs: A list of the labels of the Configuration profiles that are part of the Backup.
  backupConfigs :: (GHC.Base.Maybe ([] Data.Text.Internal.Text))
  -- | created: The date the Backup was taken.
  , backupCreated :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | disks: A list of the disks that are part of the Backup.
  , backupDisks :: (GHC.Base.Maybe ([] BackupDisks))
  -- | finished: The date the Backup completed.
  , backupFinished :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | id: The unique ID of this Backup.
  , backupId :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | label: A label for Backups that are of type \`snapshot\`.
  , backupLabel :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | status: The current state of a specific Backup.
  , backupStatus :: (GHC.Base.Maybe BackupStatus)
  -- | type: This indicates whether the Backup is an automatic Backup or manual snapshot taken by the User at a specific point in time.
  , backupType :: (GHC.Base.Maybe BackupType)
  -- | updated: The date the Backup was most recently updated.
  , backupUpdated :: (GHC.Base.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON Backup
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "configs" (backupConfigs obj) : (Data.Aeson..=) "created" (backupCreated obj) : (Data.Aeson..=) "disks" (backupDisks obj) : (Data.Aeson..=) "finished" (backupFinished obj) : (Data.Aeson..=) "id" (backupId obj) : (Data.Aeson..=) "label" (backupLabel obj) : (Data.Aeson..=) "status" (backupStatus obj) : (Data.Aeson..=) "type" (backupType obj) : (Data.Aeson..=) "updated" (backupUpdated obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "configs" (backupConfigs obj) GHC.Base.<> ((Data.Aeson..=) "created" (backupCreated obj) GHC.Base.<> ((Data.Aeson..=) "disks" (backupDisks obj) GHC.Base.<> ((Data.Aeson..=) "finished" (backupFinished obj) GHC.Base.<> ((Data.Aeson..=) "id" (backupId obj) GHC.Base.<> ((Data.Aeson..=) "label" (backupLabel obj) GHC.Base.<> ((Data.Aeson..=) "status" (backupStatus obj) GHC.Base.<> ((Data.Aeson..=) "type" (backupType obj) GHC.Base.<> (Data.Aeson..=) "updated" (backupUpdated obj)))))))))
instance Data.Aeson.Types.FromJSON.FromJSON Backup
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "Backup" (\obj -> ((((((((GHC.Base.pure Backup GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "configs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "disks")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "finished")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "updated"))
-- | Defines the data type for the schema BackupDisks
-- 
-- 
data BackupDisks = BackupDisks {
  -- | filesystem
  backupDisksFilesystem :: (GHC.Base.Maybe Disk_properties_filesystem)
  -- | label
  , backupDisksLabel :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | size
  , backupDisksSize :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON BackupDisks
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "filesystem" (backupDisksFilesystem obj) : (Data.Aeson..=) "label" (backupDisksLabel obj) : (Data.Aeson..=) "size" (backupDisksSize obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "filesystem" (backupDisksFilesystem obj) GHC.Base.<> ((Data.Aeson..=) "label" (backupDisksLabel obj) GHC.Base.<> (Data.Aeson..=) "size" (backupDisksSize obj)))
instance Data.Aeson.Types.FromJSON.FromJSON BackupDisks
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BackupDisks" (\obj -> ((GHC.Base.pure BackupDisks GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "filesystem")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "size"))
-- | Defines the enum schema BackupStatus
-- 
-- The current state of a specific Backup.
data BackupStatus
    = BackupStatusEnumOther Data.Aeson.Types.Internal.Value
    | BackupStatusEnumTyped Data.Text.Internal.Text
    | BackupStatusEnumString_failed
    | BackupStatusEnumString_needsPostProcessing
    | BackupStatusEnumString_paused
    | BackupStatusEnumString_pending
    | BackupStatusEnumString_running
    | BackupStatusEnumString_successful
    | BackupStatusEnumString_userAborted
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON BackupStatus
    where toJSON (BackupStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (BackupStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (BackupStatusEnumString_failed) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "failed"
          toJSON (BackupStatusEnumString_needsPostProcessing) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "needsPostProcessing"
          toJSON (BackupStatusEnumString_paused) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "paused"
          toJSON (BackupStatusEnumString_pending) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "pending"
          toJSON (BackupStatusEnumString_running) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running"
          toJSON (BackupStatusEnumString_successful) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "successful"
          toJSON (BackupStatusEnumString_userAborted) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "userAborted"
instance Data.Aeson.FromJSON BackupStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "failed")
                                          then BackupStatusEnumString_failed
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "needsPostProcessing")
                                                then BackupStatusEnumString_needsPostProcessing
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "paused")
                                                      then BackupStatusEnumString_paused
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "pending")
                                                            then BackupStatusEnumString_pending
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running")
                                                                  then BackupStatusEnumString_running
                                                                  else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "successful")
                                                                        then BackupStatusEnumString_successful
                                                                        else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "userAborted")
                                                                              then BackupStatusEnumString_userAborted
                                                                              else BackupStatusEnumOther val)
-- | Defines the enum schema BackupType
-- 
-- This indicates whether the Backup is an automatic Backup or manual snapshot taken by the User at a specific point in time.
data BackupType
    = BackupTypeEnumOther Data.Aeson.Types.Internal.Value
    | BackupTypeEnumTyped Data.Text.Internal.Text
    | BackupTypeEnumString_auto
    | BackupTypeEnumString_snapshot
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON BackupType
    where toJSON (BackupTypeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (BackupTypeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (BackupTypeEnumString_auto) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "auto"
          toJSON (BackupTypeEnumString_snapshot) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot"
instance Data.Aeson.FromJSON BackupType
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "auto")
                                          then BackupTypeEnumString_auto
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "snapshot")
                                                then BackupTypeEnumString_snapshot
                                                else BackupTypeEnumOther val)
-- | Defines the data type for the schema DiskRequest
-- 
-- Disk object request.
data DiskRequest = DiskRequest {
  -- | authorized_keys: A list of public SSH keys that will be automatically appended
  -- to the root user\'s \`~\/.ssh\/authorized_keys\` file when deploying from an Image.
  diskRequestAuthorized_keys :: (GHC.Base.Maybe ([] Data.Text.Internal.Text))
  -- | authorized_users: A list of usernames. If the usernames have associated SSH keys, the keys will be appended to the root users \`~\/.ssh\/authorized_keys\` file automatically when deploying from an Image.
  , diskRequestAuthorized_users :: (GHC.Base.Maybe ([] Data.Text.Internal.Text))
  -- | filesystem
  , diskRequestFilesystem :: (GHC.Base.Maybe Disk_properties_filesystem)
  -- | image: An Image ID to deploy the Linode Disk from.
  -- 
  -- Access the Images List ([GET \/images](\/docs\/api\/images\/\#images-list)) endpoint with authentication to view
  -- all available Images. Official Linode Images start with \`linode\/\`, while your Account\'s Images start with \`private\/\`. Creating
  -- a disk from a Private Image requires \`read_only\` or \`read_write\` permissions for that Image. Access the User\'s
  -- Grant Update ([PUT \/account\/users\/{username}\/grants](\/docs\/api\/account\/\#users-grants-update)) endpoint to
  -- adjust permissions for an Account Image.
  , diskRequestImage :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | label
  , diskRequestLabel :: (GHC.Base.Maybe Disk_properties_label)
  -- | root_pass: This sets the root user\'s password on a newly-created Linode Disk when deploying from an Image.
  -- 
  -- * **Required** when creating a Linode Disk from an Image, including when using a StackScript.
  -- 
  -- * Must meet a password strength score requirement that is calculated internally by the API.
  -- If the strength requirement is not met, you will receive a \`Password does not meet strength requirement\` error.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 128
  -- * Minimum length of 7
  , diskRequestRoot_pass :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | size: The size of the Disk in MB.
  -- 
  -- Images require a minimum size. Access the Image View ([GET \/images\/{imageID}](\/docs\/api\/images\/\#image-view)) endpoint to view its size.
  , diskRequestSize :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | stackscript_data: This field is required only if the StackScript being deployed requires input
  -- data from the User for successful completion. See
  -- [User Defined Fields (UDFs)](\/docs\/guides\/writing-scripts-for-use-with-linode-stackscripts-a-tutorial\/\#user-defined-fields-udfs)
  -- for more details. This field is required to be valid JSON.
  , diskRequestStackscript_data :: (GHC.Base.Maybe DiskRequestStackscript_data)
  -- | stackscript_id: A StackScript ID that will cause the referenced StackScript to be run during
  -- deployment of this Linode. A compatible \`image\` is required to use a
  -- StackScript. To get a list of available StackScript and their permitted Images
  -- see [\/stackscripts](\/docs\/api\/stackscripts\/\#stackscripts-list).
  -- This field cannot be used when deploying from a Backup or a Private Image.
  , diskRequestStackscript_id :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON DiskRequest
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "authorized_keys" (diskRequestAuthorized_keys obj) : (Data.Aeson..=) "authorized_users" (diskRequestAuthorized_users obj) : (Data.Aeson..=) "filesystem" (diskRequestFilesystem obj) : (Data.Aeson..=) "image" (diskRequestImage obj) : (Data.Aeson..=) "label" (diskRequestLabel obj) : (Data.Aeson..=) "root_pass" (diskRequestRoot_pass obj) : (Data.Aeson..=) "size" (diskRequestSize obj) : (Data.Aeson..=) "stackscript_data" (diskRequestStackscript_data obj) : (Data.Aeson..=) "stackscript_id" (diskRequestStackscript_id obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "authorized_keys" (diskRequestAuthorized_keys obj) GHC.Base.<> ((Data.Aeson..=) "authorized_users" (diskRequestAuthorized_users obj) GHC.Base.<> ((Data.Aeson..=) "filesystem" (diskRequestFilesystem obj) GHC.Base.<> ((Data.Aeson..=) "image" (diskRequestImage obj) GHC.Base.<> ((Data.Aeson..=) "label" (diskRequestLabel obj) GHC.Base.<> ((Data.Aeson..=) "root_pass" (diskRequestRoot_pass obj) GHC.Base.<> ((Data.Aeson..=) "size" (diskRequestSize obj) GHC.Base.<> ((Data.Aeson..=) "stackscript_data" (diskRequestStackscript_data obj) GHC.Base.<> (Data.Aeson..=) "stackscript_id" (diskRequestStackscript_id obj)))))))))
instance Data.Aeson.Types.FromJSON.FromJSON DiskRequest
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DiskRequest" (\obj -> ((((((((GHC.Base.pure DiskRequest GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "authorized_keys")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "authorized_users")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "filesystem")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "image")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "root_pass")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "stackscript_data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "stackscript_id"))
-- | Defines the data type for the schema DiskRequestStackscript_data
-- 
-- This field is required only if the StackScript being deployed requires input
-- data from the User for successful completion. See
-- [User Defined Fields (UDFs)](\/docs\/guides\/writing-scripts-for-use-with-linode-stackscripts-a-tutorial\/\#user-defined-fields-udfs)
-- for more details. This field is required to be valid JSON.
data DiskRequestStackscript_data = DiskRequestStackscript_data {
  
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON DiskRequestStackscript_data
    where toJSON obj = Data.Aeson.object []
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "string" ("string" :: GHC.Base.String))
instance Data.Aeson.Types.FromJSON.FromJSON DiskRequestStackscript_data
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DiskRequestStackscript_data" (\obj -> GHC.Base.pure DiskRequestStackscript_data)
-- | Defines the data type for the schema LKENodePoolRequestBody
-- 
-- Specifies a collection of Linodes which will be members of a Kubernetes cluster.
data LKENodePoolRequestBody = LKENodePoolRequestBody {
  -- | autoscaler: When enabled, the number of nodes autoscales within the defined minimum and maximum values.
  -- 
  -- When making a request, \`max\` and \`min\` require each other.
  lKENodePoolRequestBodyAutoscaler :: (GHC.Base.Maybe LKENodePoolRequestBodyAutoscaler)
  -- | count
  , lKENodePoolRequestBodyCount :: (GHC.Base.Maybe LKENodePool_properties_count)
  -- | disks: **Note**: This field should be omitted except for special use cases. The disks specified here are
  -- partitions in *addition* to the primary partition and reduce the size of the primary partition,
  -- which can lead to stability problems for the Node.
  -- 
  -- This Node Pool\'s custom disk layout. Each item in this array will create a new disk
  -- partition for each node in this Node Pool.
  -- 
  --   * The custom disk layout is applied to each node in this Node Pool.
  --   * The maximum number of custom disk partitions that can be configured is 7.
  --   * Once the requested disk paritions are allocated, the remaining disk space is allocated to the node\'s boot disk.
  --   * A Node Pool\'s custom disk layout is immutable over the lifetime of the Node Pool.
  , lKENodePoolRequestBodyDisks :: (GHC.Base.Maybe ([] LKENodePool_properties_disks_items))
  -- | tags
  , lKENodePoolRequestBodyTags :: (GHC.Base.Maybe LKENodePool_properties_tags)
  -- | type
  , lKENodePoolRequestBodyType :: (GHC.Base.Maybe LKENodePool_properties_type)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON LKENodePoolRequestBody
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "autoscaler" (lKENodePoolRequestBodyAutoscaler obj) : (Data.Aeson..=) "count" (lKENodePoolRequestBodyCount obj) : (Data.Aeson..=) "disks" (lKENodePoolRequestBodyDisks obj) : (Data.Aeson..=) "tags" (lKENodePoolRequestBodyTags obj) : (Data.Aeson..=) "type" (lKENodePoolRequestBodyType obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "autoscaler" (lKENodePoolRequestBodyAutoscaler obj) GHC.Base.<> ((Data.Aeson..=) "count" (lKENodePoolRequestBodyCount obj) GHC.Base.<> ((Data.Aeson..=) "disks" (lKENodePoolRequestBodyDisks obj) GHC.Base.<> ((Data.Aeson..=) "tags" (lKENodePoolRequestBodyTags obj) GHC.Base.<> (Data.Aeson..=) "type" (lKENodePoolRequestBodyType obj)))))
instance Data.Aeson.Types.FromJSON.FromJSON LKENodePoolRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "LKENodePoolRequestBody" (\obj -> ((((GHC.Base.pure LKENodePoolRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "autoscaler")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "count")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "disks")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tags")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "type"))
-- | Defines the data type for the schema LKENodePoolRequestBodyAutoscaler
-- 
-- When enabled, the number of nodes autoscales within the defined minimum and maximum values.
-- 
-- When making a request, \`max\` and \`min\` require each other.
data LKENodePoolRequestBodyAutoscaler = LKENodePoolRequestBodyAutoscaler {
  -- | enabled: Whether autoscaling is enabled for this Node Pool. Defaults to \`false\`.
  lKENodePoolRequestBodyAutoscalerEnabled :: (GHC.Base.Maybe GHC.Types.Bool)
  -- | max: The maximum number of nodes to autoscale to. Defaults to the Node Pool\'s \`count\`. Defaults to the value provided by the \`count\` field.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 1.0
  , lKENodePoolRequestBodyAutoscalerMax :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | min: The minimum number of nodes to autoscale to. Defaults to the Node Pool\'s \`count\`.
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 1.0
  , lKENodePoolRequestBodyAutoscalerMin :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON LKENodePoolRequestBodyAutoscaler
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "enabled" (lKENodePoolRequestBodyAutoscalerEnabled obj) : (Data.Aeson..=) "max" (lKENodePoolRequestBodyAutoscalerMax obj) : (Data.Aeson..=) "min" (lKENodePoolRequestBodyAutoscalerMin obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "enabled" (lKENodePoolRequestBodyAutoscalerEnabled obj) GHC.Base.<> ((Data.Aeson..=) "max" (lKENodePoolRequestBodyAutoscalerMax obj) GHC.Base.<> (Data.Aeson..=) "min" (lKENodePoolRequestBodyAutoscalerMin obj)))
instance Data.Aeson.Types.FromJSON.FromJSON LKENodePoolRequestBodyAutoscaler
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "LKENodePoolRequestBodyAutoscaler" (\obj -> ((GHC.Base.pure LKENodePoolRequestBodyAutoscaler GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "enabled")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "max")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "min"))
-- | Defines the data type for the schema LinodeRequest
-- 
-- Common properties for creating and rebuilding Linodes.
data LinodeRequest = LinodeRequest {
  -- | authorized_keys
  linodeRequestAuthorized_keys :: (GHC.Base.Maybe [Data.Text.Text])
  -- | authorized_users
  , linodeRequestAuthorized_users :: (GHC.Base.Maybe [Data.Text.Text])
  -- | booted: This field defaults to \`true\` if the Linode is created with an Image or from a Backup.
  -- If it is deployed from an Image or a Backup and you wish it to remain \`offline\` after deployment, set this to \`false\`.
  , linodeRequestBooted :: (GHC.Base.Maybe GHC.Types.Bool)
  -- | image
  , linodeRequestImage :: (GHC.Base.Maybe Data.Text.Text)
  -- | root_pass
  , linodeRequestRoot_pass :: (GHC.Base.Maybe Data.Text.Text)
  -- | stackscript_data
  , linodeRequestStackscript_data :: (GHC.Base.Maybe Data.Text.Text)
  -- | stackscript_id
  , linodeRequestStackscript_id :: (GHC.Base.Maybe Data.Text.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON LinodeRequest
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "authorized_keys" (linodeRequestAuthorized_keys obj) : (Data.Aeson..=) "authorized_users" (linodeRequestAuthorized_users obj) : (Data.Aeson..=) "booted" (linodeRequestBooted obj) : (Data.Aeson..=) "image" (linodeRequestImage obj) : (Data.Aeson..=) "root_pass" (linodeRequestRoot_pass obj) : (Data.Aeson..=) "stackscript_data" (linodeRequestStackscript_data obj) : (Data.Aeson..=) "stackscript_id" (linodeRequestStackscript_id obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "authorized_keys" (linodeRequestAuthorized_keys obj) GHC.Base.<> ((Data.Aeson..=) "authorized_users" (linodeRequestAuthorized_users obj) GHC.Base.<> ((Data.Aeson..=) "booted" (linodeRequestBooted obj) GHC.Base.<> ((Data.Aeson..=) "image" (linodeRequestImage obj) GHC.Base.<> ((Data.Aeson..=) "root_pass" (linodeRequestRoot_pass obj) GHC.Base.<> ((Data.Aeson..=) "stackscript_data" (linodeRequestStackscript_data obj) GHC.Base.<> (Data.Aeson..=) "stackscript_id" (linodeRequestStackscript_id obj)))))))
instance Data.Aeson.Types.FromJSON.FromJSON LinodeRequest
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "LinodeRequest" (\obj -> ((((((GHC.Base.pure LinodeRequest GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "authorized_keys")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "authorized_users")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "booted")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "image")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "root_pass")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "stackscript_data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "stackscript_id"))
-- | Defines the data type for the schema Volume
-- 
-- A Block Storage Volume associated with your Account.
data Volume = Volume {
  -- | created: When this Volume was created.
  volumeCreated :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | filesystem_path: The full filesystem path for the Volume based on the Volume\'s label. Path is \/dev\/disk\/by-id\/scsi-0Linode_Volume_ + Volume label.
  , volumeFilesystem_path :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | hardware_type: The storage type of this Volume.
  , volumeHardware_type :: (GHC.Base.Maybe VolumeHardware_type)
  -- | id: The unique ID of this Volume.
  , volumeId :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | label: The Volume\'s label is for display purposes only.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 32
  -- * Minimum length of 1
  -- * Must match pattern \'^[a-zA-Z]((?!--|__)[a-zA-Z0-9-_])+\$\'
  , volumeLabel :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | linode_id: If a Volume is attached to a specific Linode, the ID of that Linode will be displayed here.
  , volumeLinode_id :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | linode_label: If a Volume is attached to a specific Linode, the label of that Linode will be displayed here.
  , volumeLinode_label :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | region
  , volumeRegion :: (GHC.Base.Maybe Data.Text.Text)
  -- | size: The Volume\'s size, in GiB.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 10240.0
  , volumeSize :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | status: The current status of the volume.  Can be one of:
  -- 
  --   * \`creating\` - the Volume is being created and is not yet available
  --     for use.
  --   * \`active\` - the Volume is online and available for use.
  --   * \`resizing\` - the Volume is in the process of upgrading
  --     its current capacity.
  --   * \`contact_support\` - there is a problem with your Volume. Please
  --     [open a Support Ticket](\/docs\/api\/support\/\#support-ticket-open) to resolve the issue.
  , volumeStatus :: (GHC.Base.Maybe VolumeStatus)
  -- | tags: An array of Tags applied to this object.  Tags are for organizational purposes only.
  , volumeTags :: (GHC.Base.Maybe ([] Data.Text.Internal.Text))
  -- | updated: When this Volume was last updated.
  , volumeUpdated :: (GHC.Base.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON Volume
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "created" (volumeCreated obj) : (Data.Aeson..=) "filesystem_path" (volumeFilesystem_path obj) : (Data.Aeson..=) "hardware_type" (volumeHardware_type obj) : (Data.Aeson..=) "id" (volumeId obj) : (Data.Aeson..=) "label" (volumeLabel obj) : (Data.Aeson..=) "linode_id" (volumeLinode_id obj) : (Data.Aeson..=) "linode_label" (volumeLinode_label obj) : (Data.Aeson..=) "region" (volumeRegion obj) : (Data.Aeson..=) "size" (volumeSize obj) : (Data.Aeson..=) "status" (volumeStatus obj) : (Data.Aeson..=) "tags" (volumeTags obj) : (Data.Aeson..=) "updated" (volumeUpdated obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "created" (volumeCreated obj) GHC.Base.<> ((Data.Aeson..=) "filesystem_path" (volumeFilesystem_path obj) GHC.Base.<> ((Data.Aeson..=) "hardware_type" (volumeHardware_type obj) GHC.Base.<> ((Data.Aeson..=) "id" (volumeId obj) GHC.Base.<> ((Data.Aeson..=) "label" (volumeLabel obj) GHC.Base.<> ((Data.Aeson..=) "linode_id" (volumeLinode_id obj) GHC.Base.<> ((Data.Aeson..=) "linode_label" (volumeLinode_label obj) GHC.Base.<> ((Data.Aeson..=) "region" (volumeRegion obj) GHC.Base.<> ((Data.Aeson..=) "size" (volumeSize obj) GHC.Base.<> ((Data.Aeson..=) "status" (volumeStatus obj) GHC.Base.<> ((Data.Aeson..=) "tags" (volumeTags obj) GHC.Base.<> (Data.Aeson..=) "updated" (volumeUpdated obj))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON Volume
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "Volume" (\obj -> (((((((((((GHC.Base.pure Volume GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "filesystem_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "hardware_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "linode_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "linode_label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "region")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tags")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "updated"))
-- | Defines the enum schema VolumeHardware_type
-- 
-- The storage type of this Volume.
data VolumeHardware_type
    = VolumeHardware_typeEnumOther Data.Aeson.Types.Internal.Value
    | VolumeHardware_typeEnumTyped Data.Text.Internal.Text
    | VolumeHardware_typeEnumString_hdd
    | VolumeHardware_typeEnumString_nvme
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON VolumeHardware_type
    where toJSON (VolumeHardware_typeEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (VolumeHardware_typeEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (VolumeHardware_typeEnumString_hdd) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "hdd"
          toJSON (VolumeHardware_typeEnumString_nvme) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "nvme"
instance Data.Aeson.FromJSON VolumeHardware_type
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "hdd")
                                          then VolumeHardware_typeEnumString_hdd
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "nvme")
                                                then VolumeHardware_typeEnumString_nvme
                                                else VolumeHardware_typeEnumOther val)
-- | Defines the enum schema VolumeStatus
-- 
-- The current status of the volume.  Can be one of:
-- 
--   * \`creating\` - the Volume is being created and is not yet available
--     for use.
--   * \`active\` - the Volume is online and available for use.
--   * \`resizing\` - the Volume is in the process of upgrading
--     its current capacity.
--   * \`contact_support\` - there is a problem with your Volume. Please
--     [open a Support Ticket](\/docs\/api\/support\/\#support-ticket-open) to resolve the issue.
data VolumeStatus
    = VolumeStatusEnumOther Data.Aeson.Types.Internal.Value
    | VolumeStatusEnumTyped Data.Text.Internal.Text
    | VolumeStatusEnumString_active
    | VolumeStatusEnumString_contact_support
    | VolumeStatusEnumString_creating
    | VolumeStatusEnumString_resizing
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON VolumeStatus
    where toJSON (VolumeStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (VolumeStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (VolumeStatusEnumString_active) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "active"
          toJSON (VolumeStatusEnumString_contact_support) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "contact_support"
          toJSON (VolumeStatusEnumString_creating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating"
          toJSON (VolumeStatusEnumString_resizing) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "resizing"
instance Data.Aeson.FromJSON VolumeStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "active")
                                          then VolumeStatusEnumString_active
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "contact_support")
                                                then VolumeStatusEnumString_contact_support
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "creating")
                                                      then VolumeStatusEnumString_creating
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "resizing")
                                                            then VolumeStatusEnumString_resizing
                                                            else VolumeStatusEnumOther val)
