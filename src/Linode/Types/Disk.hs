-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the types generated from the schema Disk
module Linode.Types.Disk where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Linode.Common

-- | Defines the data type for the schema Disk
-- 
-- 
data Disk = Disk {
  -- | created: When this Disk was created.
  diskCreated :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | filesystem: The Disk filesystem can be one of:
  -- 
  --   * raw - No filesystem, just a raw binary stream.
  --   * swap - Linux swap area.
  --   * ext3 - The ext3 journaling filesystem for Linux.
  --   * ext4 - The ext4 journaling filesystem for Linux.
  --   * initrd - initrd (uncompressed initrd, ext2, max 32 MB).
  , diskFilesystem :: (GHC.Base.Maybe DiskFilesystem)
  -- | id: This Disk\'s ID which must be provided for all operations impacting this Disk.
  , diskId :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | label: The Disk\'s label is for display purposes only.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 48
  -- * Minimum length of 1
  , diskLabel :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | size: The size of the Disk in MB.
  , diskSize :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | status: A brief description of this Disk\'s current state. This field may change without direct action from you, as a result of operations performed to the Disk or the Linode containing the Disk.
  , diskStatus :: (GHC.Base.Maybe DiskStatus)
  -- | updated: When this Disk was last updated.
  , diskUpdated :: (GHC.Base.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON Disk
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "created" (diskCreated obj) : (Data.Aeson..=) "filesystem" (diskFilesystem obj) : (Data.Aeson..=) "id" (diskId obj) : (Data.Aeson..=) "label" (diskLabel obj) : (Data.Aeson..=) "size" (diskSize obj) : (Data.Aeson..=) "status" (diskStatus obj) : (Data.Aeson..=) "updated" (diskUpdated obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "created" (diskCreated obj) GHC.Base.<> ((Data.Aeson..=) "filesystem" (diskFilesystem obj) GHC.Base.<> ((Data.Aeson..=) "id" (diskId obj) GHC.Base.<> ((Data.Aeson..=) "label" (diskLabel obj) GHC.Base.<> ((Data.Aeson..=) "size" (diskSize obj) GHC.Base.<> ((Data.Aeson..=) "status" (diskStatus obj) GHC.Base.<> (Data.Aeson..=) "updated" (diskUpdated obj)))))))
instance Data.Aeson.Types.FromJSON.FromJSON Disk
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "Disk" (\obj -> ((((((GHC.Base.pure Disk GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "filesystem")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "size")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "updated"))
-- | Defines the enum schema DiskFilesystem
-- 
-- The Disk filesystem can be one of:
-- 
--   * raw - No filesystem, just a raw binary stream.
--   * swap - Linux swap area.
--   * ext3 - The ext3 journaling filesystem for Linux.
--   * ext4 - The ext4 journaling filesystem for Linux.
--   * initrd - initrd (uncompressed initrd, ext2, max 32 MB).
data DiskFilesystem
    = DiskFilesystemEnumOther Data.Aeson.Types.Internal.Value
    | DiskFilesystemEnumTyped Data.Text.Internal.Text
    | DiskFilesystemEnumString_ext3
    | DiskFilesystemEnumString_ext4
    | DiskFilesystemEnumString_initrd
    | DiskFilesystemEnumString_raw
    | DiskFilesystemEnumString_swap
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON DiskFilesystem
    where toJSON (DiskFilesystemEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (DiskFilesystemEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (DiskFilesystemEnumString_ext3) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ext3"
          toJSON (DiskFilesystemEnumString_ext4) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ext4"
          toJSON (DiskFilesystemEnumString_initrd) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "initrd"
          toJSON (DiskFilesystemEnumString_raw) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "raw"
          toJSON (DiskFilesystemEnumString_swap) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "swap"
instance Data.Aeson.FromJSON DiskFilesystem
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ext3")
                                          then DiskFilesystemEnumString_ext3
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ext4")
                                                then DiskFilesystemEnumString_ext4
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "initrd")
                                                      then DiskFilesystemEnumString_initrd
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "raw")
                                                            then DiskFilesystemEnumString_raw
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "swap")
                                                                  then DiskFilesystemEnumString_swap
                                                                  else DiskFilesystemEnumOther val)
-- | Defines the enum schema DiskStatus
-- 
-- A brief description of this Disk\'s current state. This field may change without direct action from you, as a result of operations performed to the Disk or the Linode containing the Disk.
data DiskStatus
    = DiskStatusEnumOther Data.Aeson.Types.Internal.Value
    | DiskStatusEnumTyped Data.Text.Internal.Text
    | DiskStatusEnumString_deleting
    | DiskStatusEnumString_not_ready
    | DiskStatusEnumString_ready
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON DiskStatus
    where toJSON (DiskStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (DiskStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (DiskStatusEnumString_deleting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting"
          toJSON (DiskStatusEnumString_not_ready) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "not ready"
          toJSON (DiskStatusEnumString_ready) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ready"
instance Data.Aeson.FromJSON DiskStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting")
                                          then DiskStatusEnumString_deleting
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "not ready")
                                                then DiskStatusEnumString_not_ready
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "ready")
                                                      then DiskStatusEnumString_ready
                                                      else DiskStatusEnumOther val)