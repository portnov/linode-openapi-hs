-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the types generated from the schema Domain
module Linode.Types.Domain where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Linode.Common
import Linode.TypeAlias

-- | Defines the object schema located at @components.schemas.Domain@ in the specification.
-- 
-- A domain zonefile in our DNS system.  You must own the domain name and tell your registrar to use Linode\'s nameservers in order for a domain in our system to be treated as authoritative.
data Domain = Domain {
  -- | axfr_ips: The list of IPs that may perform a zone transfer for this Domain. This is potentially dangerous, and should be set to an empty list unless you intend to use it.
  domainAxfrIps :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | description: A description for this Domain. This is for display purposes only.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , domainDescription :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | domain: The domain this Domain represents. Domain labels cannot be longer than 63 characters and must conform to [RFC1035](https:\/\/tools.ietf.org\/html\/rfc1035). Domains must be unique on Linode\'s platform, including across different Linode accounts; there cannot be two Domains representing the same domain.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  -- * Must match pattern \'\\A(\\*\\.)?([a-zA-Z0-9-_]{1,63}\\.)+([a-zA-Z]{2,3}\\.)?([a-zA-Z]{2,16}|xn--[a-zA-Z0-9]+)\\Z\'
  , domainDomain :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | expire_sec: The amount of time in seconds that may pass before this Domain is no longer
  -- authoritative.
  -- 
  -- * Valid values are
  -- 0, 300, 3600, 7200, 14400, 28800, 57600, 86400, 172800, 345600, 604800, 1209600, and 2419200.
  -- 
  -- * Any other value is rounded up to the nearest valid value.
  -- 
  -- * A value of 0 is equivalent to the default value of 1209600.
  , domainExpireSec :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | group: The group this Domain belongs to.  This is for display purposes only.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 50
  -- * Minimum length of 1
  , domainGroup :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | id: This Domain\'s unique ID
  , domainId :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | master_ips: The IP addresses representing the master DNS for this Domain. At least one value is required for \`type\` slave Domains.
  , domainMasterIps :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | refresh_sec: The amount of time in seconds before this Domain should be refreshed.
  -- 
  -- * Valid values are
  -- 0, 300, 3600, 7200, 14400, 28800, 57600, 86400, 172800, 345600, 604800, 1209600, and 2419200.
  -- 
  -- * Any other value is rounded up to the nearest valid value.
  -- 
  -- * A value of 0 is equivalent to the default value of 14400.
  , domainRefreshSec :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | retry_sec: The interval, in seconds, at which a failed refresh should be retried.
  -- 
  -- * Valid values are
  -- 0, 300, 3600, 7200, 14400, 28800, 57600, 86400, 172800, 345600, 604800, 1209600, and 2419200.
  -- 
  -- * Any other value is rounded up to the nearest valid value.
  -- 
  -- * A value of 0 is equivalent to the default value of 14400.
  , domainRetrySec :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | soa_email: Start of Authority email address. This is required for \`type\` master Domains.
  , domainSoaEmail :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | status: Used to control whether this Domain is currently being rendered.
  , domainStatus :: (GHC.Maybe.Maybe DomainStatus')
  -- | tags: An array of tags applied to this object.  Tags are for organizational purposes only.
  , domainTags :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | ttl_sec: \"Time to Live\" - the amount of time in seconds that this Domain\'s records may be cached by resolvers or other domain servers.
  -- * Valid values are 0, 300, 3600, 7200, 14400, 28800, 57600, 86400, 172800, 345600, 604800, 1209600, and 2419200.
  -- * Any other value is rounded up to the nearest valid value.
  -- * A value of 0 is equivalent to the default value of 86400.
  , domainTtlSec :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | type: Whether this Domain represents the authoritative source of information for the domain it describes (\"master\"), or whether it is a read-only copy of a master (\"slave\").
  , domainType :: (GHC.Maybe.Maybe DomainType')
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON Domain
    where toJSON obj = Data.Aeson.Types.Internal.object ("axfr_ips" Data.Aeson.Types.ToJSON..= domainAxfrIps obj : "description" Data.Aeson.Types.ToJSON..= domainDescription obj : "domain" Data.Aeson.Types.ToJSON..= domainDomain obj : "expire_sec" Data.Aeson.Types.ToJSON..= domainExpireSec obj : "group" Data.Aeson.Types.ToJSON..= domainGroup obj : "id" Data.Aeson.Types.ToJSON..= domainId obj : "master_ips" Data.Aeson.Types.ToJSON..= domainMasterIps obj : "refresh_sec" Data.Aeson.Types.ToJSON..= domainRefreshSec obj : "retry_sec" Data.Aeson.Types.ToJSON..= domainRetrySec obj : "soa_email" Data.Aeson.Types.ToJSON..= domainSoaEmail obj : "status" Data.Aeson.Types.ToJSON..= domainStatus obj : "tags" Data.Aeson.Types.ToJSON..= domainTags obj : "ttl_sec" Data.Aeson.Types.ToJSON..= domainTtlSec obj : "type" Data.Aeson.Types.ToJSON..= domainType obj : GHC.Base.mempty)
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (("axfr_ips" Data.Aeson.Types.ToJSON..= domainAxfrIps obj) GHC.Base.<> (("description" Data.Aeson.Types.ToJSON..= domainDescription obj) GHC.Base.<> (("domain" Data.Aeson.Types.ToJSON..= domainDomain obj) GHC.Base.<> (("expire_sec" Data.Aeson.Types.ToJSON..= domainExpireSec obj) GHC.Base.<> (("group" Data.Aeson.Types.ToJSON..= domainGroup obj) GHC.Base.<> (("id" Data.Aeson.Types.ToJSON..= domainId obj) GHC.Base.<> (("master_ips" Data.Aeson.Types.ToJSON..= domainMasterIps obj) GHC.Base.<> (("refresh_sec" Data.Aeson.Types.ToJSON..= domainRefreshSec obj) GHC.Base.<> (("retry_sec" Data.Aeson.Types.ToJSON..= domainRetrySec obj) GHC.Base.<> (("soa_email" Data.Aeson.Types.ToJSON..= domainSoaEmail obj) GHC.Base.<> (("status" Data.Aeson.Types.ToJSON..= domainStatus obj) GHC.Base.<> (("tags" Data.Aeson.Types.ToJSON..= domainTags obj) GHC.Base.<> (("ttl_sec" Data.Aeson.Types.ToJSON..= domainTtlSec obj) GHC.Base.<> ("type" Data.Aeson.Types.ToJSON..= domainType obj))))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON Domain
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "Domain" (\obj -> (((((((((((((GHC.Base.pure Domain GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "axfr_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "domain")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "expire_sec")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "group")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "master_ips")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "refresh_sec")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "retry_sec")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "soa_email")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tags")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "ttl_sec")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "type"))
-- | Create a new 'Domain' with all required fields.
mkDomain :: Domain
mkDomain = Domain{domainAxfrIps = GHC.Maybe.Nothing,
                  domainDescription = GHC.Maybe.Nothing,
                  domainDomain = GHC.Maybe.Nothing,
                  domainExpireSec = GHC.Maybe.Nothing,
                  domainGroup = GHC.Maybe.Nothing,
                  domainId = GHC.Maybe.Nothing,
                  domainMasterIps = GHC.Maybe.Nothing,
                  domainRefreshSec = GHC.Maybe.Nothing,
                  domainRetrySec = GHC.Maybe.Nothing,
                  domainSoaEmail = GHC.Maybe.Nothing,
                  domainStatus = GHC.Maybe.Nothing,
                  domainTags = GHC.Maybe.Nothing,
                  domainTtlSec = GHC.Maybe.Nothing,
                  domainType = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @components.schemas.Domain.properties.status@ in the specification.
-- 
-- Used to control whether this Domain is currently being rendered.
data DomainStatus' =
   DomainStatus'Other Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DomainStatus'Typed Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DomainStatus'EnumDisabled -- ^ Represents the JSON value @"disabled"@
  | DomainStatus'EnumActive -- ^ Represents the JSON value @"active"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DomainStatus'
    where toJSON (DomainStatus'Other val) = val
          toJSON (DomainStatus'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DomainStatus'EnumDisabled) = "disabled"
          toJSON (DomainStatus'EnumActive) = "active"
instance Data.Aeson.Types.FromJSON.FromJSON DomainStatus'
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "disabled" -> DomainStatus'EnumDisabled
                                            | val GHC.Classes.== "active" -> DomainStatus'EnumActive
                                            | GHC.Base.otherwise -> DomainStatus'Other val)
-- | Defines the enum schema located at @components.schemas.Domain.properties.type@ in the specification.
-- 
-- Whether this Domain represents the authoritative source of information for the domain it describes (\"master\"), or whether it is a read-only copy of a master (\"slave\").
data DomainType' =
   DomainType'Other Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DomainType'Typed Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DomainType'EnumMaster -- ^ Represents the JSON value @"master"@
  | DomainType'EnumSlave -- ^ Represents the JSON value @"slave"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DomainType'
    where toJSON (DomainType'Other val) = val
          toJSON (DomainType'Typed val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DomainType'EnumMaster) = "master"
          toJSON (DomainType'EnumSlave) = "slave"
instance Data.Aeson.Types.FromJSON.FromJSON DomainType'
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "master" -> DomainType'EnumMaster
                                            | val GHC.Classes.== "slave" -> DomainType'EnumSlave
                                            | GHC.Base.otherwise -> DomainType'Other val)
