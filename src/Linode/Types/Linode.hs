-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

-- | Contains the types generated from the schema Linode
module Linode.Types.Linode where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Functor
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Generics
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Linode.Common

-- | Defines the data type for the schema Linode
-- 
-- 
data Linode = Linode {
  -- | alerts
  linodeAlerts :: (GHC.Base.Maybe LinodeAlerts)
  -- | backups: Information about this Linode\'s backups status. For information about available backups, see [\/linode\/instances\/{linodeId}\/backups](\/docs\/api\/linode-instances\/\#backups-list).
  , linodeBackups :: (GHC.Base.Maybe LinodeBackups)
  -- | created: When this Linode was created.
  , linodeCreated :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | group: A deprecated property denoting a group label for this Linode.
  , linodeGroup :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | hypervisor: The virtualization software powering this Linode.
  , linodeHypervisor :: (GHC.Base.Maybe LinodeHypervisor)
  -- | id: This Linode\'s ID which must be provided for all operations impacting this Linode.
  , linodeId :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | image
  , linodeImage :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | ipv4: This Linode\'s IPv4 Addresses. Each Linode is assigned a single public IPv4 address
  -- upon creation, and may get a single private IPv4 address if needed. You may need to
  -- [open a support ticket](\/docs\/api\/support\/\#support-ticket-open)
  -- to get additional IPv4 addresses.
  -- 
  -- IPv4 addresses may be reassigned between your Linodes, or shared with other Linodes.
  -- See the [\/networking](\/docs\/api\/networking\/) endpoints for details.
  , linodeIpv4 :: (GHC.Base.Maybe ([] Data.Text.Internal.Text))
  -- | ipv6: This Linode\'s IPv6 SLAAC address. This address is specific to a Linode, and may not be shared. If the Linode has not been assigned an IPv6 address, the return value will be \`null\`.
  , linodeIpv6 :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | label: The Linode\'s label is for display purposes only. If no label is provided for a Linode,
  -- a default will be assigned.
  -- 
  -- Linode labels have the following constraints:
  -- 
  --   * Must begin and end with an alphanumeric character.
  --   * May only consist of alphanumeric characters, dashes (\`-\`), underscores (\`_\`) or periods (\`.\`).
  --   * Cannot have two dashes (\`--\`), underscores (\`__\`) or periods (\`..\`) in a row.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 3
  -- * Must match pattern \'^[a-zA-Z]((?!--|__|..)[a-zA-Z0-9-_.])+\$\'
  , linodeLabel :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | region: This is the [Region](\/docs\/api\/regions\/\#regions-list) where the Linode was deployed. A Linode\'s region can only be changed by initiating a [cross data center migration](\/docs\/api\/linode-instances\/\#dc-migrationpending-host-migration-initiate).
  , linodeRegion :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | specs: Information about the resources available to this Linode.
  , linodeSpecs :: (GHC.Base.Maybe LinodeSpecs)
  -- | status: A brief description of this Linode\'s current state. This field may change without direct action from you. For example, when a Linode goes into maintenance mode its status will display \"stopped\".
  , linodeStatus :: (GHC.Base.Maybe LinodeStatus)
  -- | tags: An array of tags applied to this object.  Tags are for organizational purposes only.
  , linodeTags :: (GHC.Base.Maybe ([] Data.Text.Internal.Text))
  -- | type: This is the [Linode Type](\/docs\/api\/linode-types\/\#types-list) that this Linode was deployed with.
  -- To change a Linode\'s Type, use [POST \/linode\/instances\/{linodeId}\/resize](\/docs\/api\/linode-instances\/\#linode-resize).
  , linodeType :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | updated: When this Linode was last updated.
  , linodeUpdated :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | watchdog_enabled: The watchdog, named Lassie, is a Shutdown Watchdog that monitors your Linode and will reboot it if it powers off unexpectedly. It works by issuing a boot job when your Linode powers off without a shutdown job being responsible.
  -- To prevent a loop, Lassie will give up if there have been more than 5 boot jobs issued within 15 minutes.
  , linodeWatchdog_enabled :: (GHC.Base.Maybe GHC.Types.Bool)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON Linode
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "alerts" (linodeAlerts obj) : (Data.Aeson..=) "backups" (linodeBackups obj) : (Data.Aeson..=) "created" (linodeCreated obj) : (Data.Aeson..=) "group" (linodeGroup obj) : (Data.Aeson..=) "hypervisor" (linodeHypervisor obj) : (Data.Aeson..=) "id" (linodeId obj) : (Data.Aeson..=) "image" (linodeImage obj) : (Data.Aeson..=) "ipv4" (linodeIpv4 obj) : (Data.Aeson..=) "ipv6" (linodeIpv6 obj) : (Data.Aeson..=) "label" (linodeLabel obj) : (Data.Aeson..=) "region" (linodeRegion obj) : (Data.Aeson..=) "specs" (linodeSpecs obj) : (Data.Aeson..=) "status" (linodeStatus obj) : (Data.Aeson..=) "tags" (linodeTags obj) : (Data.Aeson..=) "type" (linodeType obj) : (Data.Aeson..=) "updated" (linodeUpdated obj) : (Data.Aeson..=) "watchdog_enabled" (linodeWatchdog_enabled obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "alerts" (linodeAlerts obj) GHC.Base.<> ((Data.Aeson..=) "backups" (linodeBackups obj) GHC.Base.<> ((Data.Aeson..=) "created" (linodeCreated obj) GHC.Base.<> ((Data.Aeson..=) "group" (linodeGroup obj) GHC.Base.<> ((Data.Aeson..=) "hypervisor" (linodeHypervisor obj) GHC.Base.<> ((Data.Aeson..=) "id" (linodeId obj) GHC.Base.<> ((Data.Aeson..=) "image" (linodeImage obj) GHC.Base.<> ((Data.Aeson..=) "ipv4" (linodeIpv4 obj) GHC.Base.<> ((Data.Aeson..=) "ipv6" (linodeIpv6 obj) GHC.Base.<> ((Data.Aeson..=) "label" (linodeLabel obj) GHC.Base.<> ((Data.Aeson..=) "region" (linodeRegion obj) GHC.Base.<> ((Data.Aeson..=) "specs" (linodeSpecs obj) GHC.Base.<> ((Data.Aeson..=) "status" (linodeStatus obj) GHC.Base.<> ((Data.Aeson..=) "tags" (linodeTags obj) GHC.Base.<> ((Data.Aeson..=) "type" (linodeType obj) GHC.Base.<> ((Data.Aeson..=) "updated" (linodeUpdated obj) GHC.Base.<> (Data.Aeson..=) "watchdog_enabled" (linodeWatchdog_enabled obj)))))))))))))))))
instance Data.Aeson.Types.FromJSON.FromJSON Linode
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "Linode" (\obj -> ((((((((((((((((GHC.Base.pure Linode GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "alerts")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "backups")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "created")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "group")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "hypervisor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "image")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "ipv4")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "ipv6")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "label")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "region")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "specs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "tags")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "updated")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "watchdog_enabled"))
-- | Defines the data type for the schema LinodeAlerts
-- 
-- 
data LinodeAlerts = LinodeAlerts {
  -- | cpu: The percentage of CPU usage required to trigger an alert.
  -- If the average CPU usage over two hours exceeds this value, we\'ll send you an alert.
  -- Your Linode\'s total CPU capacity is represented as 100%, multiplied by its number of
  -- cores.
  -- 
  -- For example, a two core Linode\'s CPU capacity is represented as 200%. If you want
  -- to be alerted at 90% of a two core Linode\'s CPU capacity, set the alert value to \`180\`.
  -- 
  -- The default value is 90% multiplied by the number of cores.
  -- 
  -- If the value is set to \`0\` (zero), the alert is disabled.
  linodeAlertsCpu :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | io: The amount of disk IO operation per second required to trigger an alert. If the average disk IO over two hours exceeds this value, we\'ll send you an alert. If set to \`0\` (zero), this alert is disabled.
  , linodeAlertsIo :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | network_in: The amount of incoming traffic, in Mbit\/s, required to trigger an alert. If the average incoming traffic over two hours exceeds this value, we\'ll send you an alert. If this is set to \`0\` (zero), the alert is disabled.
  , linodeAlertsNetwork_in :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | network_out: The amount of outbound traffic, in Mbit\/s, required to trigger an alert. If the average outbound traffic over two hours exceeds this value, we\'ll send you an alert. If this is set to \`0\` (zero), the alert is disabled.
  , linodeAlertsNetwork_out :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | transfer_quota: The percentage of network transfer that may be used before an alert is triggered. When this value is exceeded, we\'ll alert you. If this is set to \`0\` (zero), the alert is disabled.
  , linodeAlertsTransfer_quota :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON LinodeAlerts
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "cpu" (linodeAlertsCpu obj) : (Data.Aeson..=) "io" (linodeAlertsIo obj) : (Data.Aeson..=) "network_in" (linodeAlertsNetwork_in obj) : (Data.Aeson..=) "network_out" (linodeAlertsNetwork_out obj) : (Data.Aeson..=) "transfer_quota" (linodeAlertsTransfer_quota obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "cpu" (linodeAlertsCpu obj) GHC.Base.<> ((Data.Aeson..=) "io" (linodeAlertsIo obj) GHC.Base.<> ((Data.Aeson..=) "network_in" (linodeAlertsNetwork_in obj) GHC.Base.<> ((Data.Aeson..=) "network_out" (linodeAlertsNetwork_out obj) GHC.Base.<> (Data.Aeson..=) "transfer_quota" (linodeAlertsTransfer_quota obj)))))
instance Data.Aeson.Types.FromJSON.FromJSON LinodeAlerts
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "LinodeAlerts" (\obj -> ((((GHC.Base.pure LinodeAlerts GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "cpu")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "io")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "network_in")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "network_out")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "transfer_quota"))
-- | Defines the data type for the schema LinodeBackups
-- 
-- Information about this Linode\'s backups status. For information about available backups, see [\/linode\/instances\/{linodeId}\/backups](\/docs\/api\/linode-instances\/\#backups-list).
data LinodeBackups = LinodeBackups {
  -- | enabled: If this Linode has the Backup service enabled. To enable backups, see [POST \/linode\/instances\/{linodeId}\/backups\/enable](\/docs\/api\/linode-instances\/\#backups-enable).
  linodeBackupsEnabled :: (GHC.Base.Maybe GHC.Types.Bool)
  -- | last_successful: The last successful backup date. \'null\' if there was no previous backup.
  , linodeBackupsLast_successful :: (GHC.Base.Maybe Data.Text.Internal.Text)
  -- | schedule
  , linodeBackupsSchedule :: (GHC.Base.Maybe LinodeBackupsSchedule)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON LinodeBackups
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "enabled" (linodeBackupsEnabled obj) : (Data.Aeson..=) "last_successful" (linodeBackupsLast_successful obj) : (Data.Aeson..=) "schedule" (linodeBackupsSchedule obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "enabled" (linodeBackupsEnabled obj) GHC.Base.<> ((Data.Aeson..=) "last_successful" (linodeBackupsLast_successful obj) GHC.Base.<> (Data.Aeson..=) "schedule" (linodeBackupsSchedule obj)))
instance Data.Aeson.Types.FromJSON.FromJSON LinodeBackups
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "LinodeBackups" (\obj -> ((GHC.Base.pure LinodeBackups GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "enabled")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "last_successful")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "schedule"))
-- | Defines the data type for the schema LinodeBackupsSchedule
-- 
-- 
data LinodeBackupsSchedule = LinodeBackupsSchedule {
  -- | day: The day of the week that your Linode\'s weekly Backup is taken.
  -- If not set manually, a day will be chosen for you. Backups
  -- are taken every day, but backups taken on this day are
  -- preferred when selecting backups to retain for a longer period.
  -- 
  -- 
  -- If not set manually, then when backups are initially enabled, this
  -- may come back as \`Scheduling\` until the \`day\` is automatically selected.
  linodeBackupsScheduleDay :: (GHC.Base.Maybe LinodeBackupsScheduleDay)
  -- | window: The window in which your backups will be taken, in UTC. A
  -- backups window is a two-hour span of time in which the backup
  -- may occur.
  -- 
  -- 
  -- For example, \`W10\` indicates that your backups should be
  -- taken between 10:00 and 12:00. If you do not choose a backup
  -- window, one will be selected for you automatically.
  -- 
  -- 
  -- If not set manually, when backups are initially enabled this
  -- may come back as \`Scheduling\` until the \`window\` is automatically selected.
  , linodeBackupsScheduleWindow :: (GHC.Base.Maybe LinodeBackupsScheduleWindow)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON LinodeBackupsSchedule
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "day" (linodeBackupsScheduleDay obj) : (Data.Aeson..=) "window" (linodeBackupsScheduleWindow obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "day" (linodeBackupsScheduleDay obj) GHC.Base.<> (Data.Aeson..=) "window" (linodeBackupsScheduleWindow obj))
instance Data.Aeson.Types.FromJSON.FromJSON LinodeBackupsSchedule
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "LinodeBackupsSchedule" (\obj -> (GHC.Base.pure LinodeBackupsSchedule GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "day")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "window"))
-- | Defines the enum schema LinodeBackupsScheduleDay
-- 
-- The day of the week that your Linode\'s weekly Backup is taken.
-- If not set manually, a day will be chosen for you. Backups
-- are taken every day, but backups taken on this day are
-- preferred when selecting backups to retain for a longer period.
-- 
-- 
-- If not set manually, then when backups are initially enabled, this
-- may come back as \`Scheduling\` until the \`day\` is automatically selected.
data LinodeBackupsScheduleDay
    = LinodeBackupsScheduleDayEnumOther Data.Aeson.Types.Internal.Value
    | LinodeBackupsScheduleDayEnumTyped Data.Text.Internal.Text
    | LinodeBackupsScheduleDayEnumString_Friday
    | LinodeBackupsScheduleDayEnumString_Monday
    | LinodeBackupsScheduleDayEnumString_Saturday
    | LinodeBackupsScheduleDayEnumString_Scheduling
    | LinodeBackupsScheduleDayEnumString_Sunday
    | LinodeBackupsScheduleDayEnumString_Thursday
    | LinodeBackupsScheduleDayEnumString_Tuesday
    | LinodeBackupsScheduleDayEnumString_Wednesday
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON LinodeBackupsScheduleDay
    where toJSON (LinodeBackupsScheduleDayEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (LinodeBackupsScheduleDayEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (LinodeBackupsScheduleDayEnumString_Friday) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Friday"
          toJSON (LinodeBackupsScheduleDayEnumString_Monday) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Monday"
          toJSON (LinodeBackupsScheduleDayEnumString_Saturday) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Saturday"
          toJSON (LinodeBackupsScheduleDayEnumString_Scheduling) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Scheduling"
          toJSON (LinodeBackupsScheduleDayEnumString_Sunday) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Sunday"
          toJSON (LinodeBackupsScheduleDayEnumString_Thursday) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Thursday"
          toJSON (LinodeBackupsScheduleDayEnumString_Tuesday) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Tuesday"
          toJSON (LinodeBackupsScheduleDayEnumString_Wednesday) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Wednesday"
instance Data.Aeson.FromJSON LinodeBackupsScheduleDay
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Friday")
                                          then LinodeBackupsScheduleDayEnumString_Friday
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Monday")
                                                then LinodeBackupsScheduleDayEnumString_Monday
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Saturday")
                                                      then LinodeBackupsScheduleDayEnumString_Saturday
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Scheduling")
                                                            then LinodeBackupsScheduleDayEnumString_Scheduling
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Sunday")
                                                                  then LinodeBackupsScheduleDayEnumString_Sunday
                                                                  else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Thursday")
                                                                        then LinodeBackupsScheduleDayEnumString_Thursday
                                                                        else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Tuesday")
                                                                              then LinodeBackupsScheduleDayEnumString_Tuesday
                                                                              else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Wednesday")
                                                                                    then LinodeBackupsScheduleDayEnumString_Wednesday
                                                                                    else LinodeBackupsScheduleDayEnumOther val)
-- | Defines the enum schema LinodeBackupsScheduleWindow
-- 
-- The window in which your backups will be taken, in UTC. A
-- backups window is a two-hour span of time in which the backup
-- may occur.
-- 
-- 
-- For example, \`W10\` indicates that your backups should be
-- taken between 10:00 and 12:00. If you do not choose a backup
-- window, one will be selected for you automatically.
-- 
-- 
-- If not set manually, when backups are initially enabled this
-- may come back as \`Scheduling\` until the \`window\` is automatically selected.
data LinodeBackupsScheduleWindow
    = LinodeBackupsScheduleWindowEnumOther Data.Aeson.Types.Internal.Value
    | LinodeBackupsScheduleWindowEnumTyped Data.Text.Internal.Text
    | LinodeBackupsScheduleWindowEnumString_Scheduling
    | LinodeBackupsScheduleWindowEnumString_W0
    | LinodeBackupsScheduleWindowEnumString_W10
    | LinodeBackupsScheduleWindowEnumString_W12
    | LinodeBackupsScheduleWindowEnumString_W14
    | LinodeBackupsScheduleWindowEnumString_W16
    | LinodeBackupsScheduleWindowEnumString_W18
    | LinodeBackupsScheduleWindowEnumString_W2
    | LinodeBackupsScheduleWindowEnumString_W20
    | LinodeBackupsScheduleWindowEnumString_W22
    | LinodeBackupsScheduleWindowEnumString_W4
    | LinodeBackupsScheduleWindowEnumString_W6
    | LinodeBackupsScheduleWindowEnumString_W8
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON LinodeBackupsScheduleWindow
    where toJSON (LinodeBackupsScheduleWindowEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (LinodeBackupsScheduleWindowEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (LinodeBackupsScheduleWindowEnumString_Scheduling) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Scheduling"
          toJSON (LinodeBackupsScheduleWindowEnumString_W0) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W0"
          toJSON (LinodeBackupsScheduleWindowEnumString_W10) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W10"
          toJSON (LinodeBackupsScheduleWindowEnumString_W12) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W12"
          toJSON (LinodeBackupsScheduleWindowEnumString_W14) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W14"
          toJSON (LinodeBackupsScheduleWindowEnumString_W16) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W16"
          toJSON (LinodeBackupsScheduleWindowEnumString_W18) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W18"
          toJSON (LinodeBackupsScheduleWindowEnumString_W2) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W2"
          toJSON (LinodeBackupsScheduleWindowEnumString_W20) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W20"
          toJSON (LinodeBackupsScheduleWindowEnumString_W22) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W22"
          toJSON (LinodeBackupsScheduleWindowEnumString_W4) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W4"
          toJSON (LinodeBackupsScheduleWindowEnumString_W6) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W6"
          toJSON (LinodeBackupsScheduleWindowEnumString_W8) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W8"
instance Data.Aeson.FromJSON LinodeBackupsScheduleWindow
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "Scheduling")
                                          then LinodeBackupsScheduleWindowEnumString_Scheduling
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W0")
                                                then LinodeBackupsScheduleWindowEnumString_W0
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W10")
                                                      then LinodeBackupsScheduleWindowEnumString_W10
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W12")
                                                            then LinodeBackupsScheduleWindowEnumString_W12
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W14")
                                                                  then LinodeBackupsScheduleWindowEnumString_W14
                                                                  else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W16")
                                                                        then LinodeBackupsScheduleWindowEnumString_W16
                                                                        else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W18")
                                                                              then LinodeBackupsScheduleWindowEnumString_W18
                                                                              else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W2")
                                                                                    then LinodeBackupsScheduleWindowEnumString_W2
                                                                                    else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W20")
                                                                                          then LinodeBackupsScheduleWindowEnumString_W20
                                                                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W22")
                                                                                                then LinodeBackupsScheduleWindowEnumString_W22
                                                                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W4")
                                                                                                      then LinodeBackupsScheduleWindowEnumString_W4
                                                                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W6")
                                                                                                            then LinodeBackupsScheduleWindowEnumString_W6
                                                                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "W8")
                                                                                                                  then LinodeBackupsScheduleWindowEnumString_W8
                                                                                                                  else LinodeBackupsScheduleWindowEnumOther val)
-- | Defines the enum schema LinodeHypervisor
-- 
-- The virtualization software powering this Linode.
data LinodeHypervisor
    = LinodeHypervisorEnumOther Data.Aeson.Types.Internal.Value
    | LinodeHypervisorEnumTyped Data.Text.Internal.Text
    | LinodeHypervisorEnumString_kvm
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON LinodeHypervisor
    where toJSON (LinodeHypervisorEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (LinodeHypervisorEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (LinodeHypervisorEnumString_kvm) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "kvm"
instance Data.Aeson.FromJSON LinodeHypervisor
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "kvm")
                                          then LinodeHypervisorEnumString_kvm
                                          else LinodeHypervisorEnumOther val)
-- | Defines the data type for the schema LinodeSpecs
-- 
-- Information about the resources available to this Linode.
data LinodeSpecs = LinodeSpecs {
  -- | disk: The amount of storage space, in MB, this Linode has access to. A typical Linode will divide this space between a primary disk with an \`image\` deployed to it, and a swap disk, usually 512 MB. This is the default configuration created when deploying a Linode with an \`image\` through [POST \/linode\/instances](\/docs\/api\/linode-instances\/\#linode-create). While this configuration is suitable for 99% of use cases, if you need finer control over your Linode\'s disks, see the [\/linode\/instances\/{linodeId}\/disks](\/docs\/api\/linode-instances\/\#disks-list) endpoints.
  linodeSpecsDisk :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | memory: The amount of RAM, in MB, this Linode has access to. Typically a Linode will choose to boot with all of its available RAM, but this can be configured in a Config profile, see the [\/linode\/instances\/{linodeId}\/configs](\/docs\/api\/linode-instances\/\#configuration-profiles-list) endpoints and the LinodeConfig object for more information.
  , linodeSpecsMemory :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | transfer: The amount of network transfer this Linode is allotted each month.
  , linodeSpecsTransfer :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  -- | vcpus: The number of vcpus this Linode has access to. Typically a Linode will choose to boot with all of its available vcpus, but this can be configured in a Config Profile, see the [\/linode\/instances\/{linodeId}\/configs](\/docs\/api\/linode-instances\/\#configuration-profiles-list) endpoints and the LinodeConfig object for more information.
  , linodeSpecsVcpus :: (GHC.Base.Maybe GHC.Integer.Type.Integer)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.ToJSON LinodeSpecs
    where toJSON obj = Data.Aeson.object ((Data.Aeson..=) "disk" (linodeSpecsDisk obj) : (Data.Aeson..=) "memory" (linodeSpecsMemory obj) : (Data.Aeson..=) "transfer" (linodeSpecsTransfer obj) : (Data.Aeson..=) "vcpus" (linodeSpecsVcpus obj) : [])
          toEncoding obj = Data.Aeson.pairs ((Data.Aeson..=) "disk" (linodeSpecsDisk obj) GHC.Base.<> ((Data.Aeson..=) "memory" (linodeSpecsMemory obj) GHC.Base.<> ((Data.Aeson..=) "transfer" (linodeSpecsTransfer obj) GHC.Base.<> (Data.Aeson..=) "vcpus" (linodeSpecsVcpus obj))))
instance Data.Aeson.Types.FromJSON.FromJSON LinodeSpecs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "LinodeSpecs" (\obj -> (((GHC.Base.pure LinodeSpecs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "disk")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "memory")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "transfer")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:? "vcpus"))
-- | Defines the enum schema LinodeStatus
-- 
-- A brief description of this Linode\'s current state. This field may change without direct action from you. For example, when a Linode goes into maintenance mode its status will display \"stopped\".
data LinodeStatus
    = LinodeStatusEnumOther Data.Aeson.Types.Internal.Value
    | LinodeStatusEnumTyped Data.Text.Internal.Text
    | LinodeStatusEnumString_booting
    | LinodeStatusEnumString_cloning
    | LinodeStatusEnumString_deleting
    | LinodeStatusEnumString_migrating
    | LinodeStatusEnumString_offline
    | LinodeStatusEnumString_provisioning
    | LinodeStatusEnumString_rebooting
    | LinodeStatusEnumString_rebuilding
    | LinodeStatusEnumString_restoring
    | LinodeStatusEnumString_running
    | LinodeStatusEnumString_shutting_down
    | LinodeStatusEnumString_stopped
    deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.ToJSON LinodeStatus
    where toJSON (LinodeStatusEnumOther patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (LinodeStatusEnumTyped patternName) = Data.Aeson.Types.ToJSON.toJSON patternName
          toJSON (LinodeStatusEnumString_booting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "booting"
          toJSON (LinodeStatusEnumString_cloning) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "cloning"
          toJSON (LinodeStatusEnumString_deleting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting"
          toJSON (LinodeStatusEnumString_migrating) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "migrating"
          toJSON (LinodeStatusEnumString_offline) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "offline"
          toJSON (LinodeStatusEnumString_provisioning) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "provisioning"
          toJSON (LinodeStatusEnumString_rebooting) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebooting"
          toJSON (LinodeStatusEnumString_rebuilding) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebuilding"
          toJSON (LinodeStatusEnumString_restoring) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "restoring"
          toJSON (LinodeStatusEnumString_running) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running"
          toJSON (LinodeStatusEnumString_shutting_down) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "shutting_down"
          toJSON (LinodeStatusEnumString_stopped) = Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "stopped"
instance Data.Aeson.FromJSON LinodeStatus
    where parseJSON val = GHC.Base.pure (if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "booting")
                                          then LinodeStatusEnumString_booting
                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "cloning")
                                                then LinodeStatusEnumString_cloning
                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "deleting")
                                                      then LinodeStatusEnumString_deleting
                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "migrating")
                                                            then LinodeStatusEnumString_migrating
                                                            else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "offline")
                                                                  then LinodeStatusEnumString_offline
                                                                  else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "provisioning")
                                                                        then LinodeStatusEnumString_provisioning
                                                                        else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebooting")
                                                                              then LinodeStatusEnumString_rebooting
                                                                              else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "rebuilding")
                                                                                    then LinodeStatusEnumString_rebuilding
                                                                                    else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "restoring")
                                                                                          then LinodeStatusEnumString_restoring
                                                                                          else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "running")
                                                                                                then LinodeStatusEnumString_running
                                                                                                else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "shutting_down")
                                                                                                      then LinodeStatusEnumString_shutting_down
                                                                                                      else if val GHC.Classes.== (Data.Aeson.Types.Internal.String GHC.Base.$ Data.Text.pack "stopped")
                                                                                                            then LinodeStatusEnumString_stopped
                                                                                                            else LinodeStatusEnumOther val)